(window.webpackJsonp=window.webpackJsonp||[]).push([[243],{398:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return p})),n.d(t,"rightToc",(function(){return u})),n.d(t,"default",(function(){return b}));var a=n(1),s=(n(0),n(1118)),r=n(1162),o=n(1121),i=n(1153),c=n(1152);const l={last_modified_on:"2020-04-01",$schema:"/.meta/.schemas/guides.json",title:"Structuring Your Log Data",description:"How to parse log data in Vector",series_position:2,author_github:"https://github.com/Jeffail",tags:["type: tutorial","domain: config"]},p={categories:[{name:"getting-started",title:"Getting Started",description:"Take Vector from zero to production in under 10 minutes.",permalink:"/guides/getting-started"}],coverLabel:"Structuring Your Log Data",description:"How to parse log data in Vector",permalink:"/guides/getting-started/structuring",readingTime:"6 min read",seriesPosition:2,source:"@site/guides/getting-started/structuring.md",tags:[{label:"type: tutorial",permalink:"/guides/tags/type-tutorial"},{label:"domain: config",permalink:"/guides/tags/domain-config"}],title:"Structuring Your Log Data",truncated:!1,prevItem:{title:"Hello World. Your First Vector Pipeline.",permalink:"/guides/getting-started/your-first-pipeline"},nextItem:{title:"Deploying Vector",permalink:"/guides/getting-started/deploying"}},u=[{value:"Tutorial",id:"tutorial",children:[{value:"Setup a basic pipeline",id:"setup-a-basic-pipeline",children:[]},{value:"Add a parsing transform",id:"add-a-parsing-transform",children:[]},{value:"Test it",id:"test-it",children:[]}]},{value:"Next Steps",id:"next-steps",children:[]}],d={rightToc:u};function b({components:e,...t}){return Object(s.b)("wrapper",Object(a.a)({},d,t,{components:e,mdxType:"MDXLayout"}),Object(s.b)("p",null,"Structured logs are like cocktails; they're cool because they're complicated.\nIn this guide we'll build a pipeline using ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/transforms/"}),"transformations"),"\nthat allows us to send unstructured ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/about/data-model/"}),"events")," through it that\nlook like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-text"}),'172.128.80.109 - Bins5273 656 [2019-05-03T13:11:48-04:00] \\"PUT /mesh\\" 406 10272\n')),Object(s.b)("p",null,"And have them coming out the other end in a structured format like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "bytes_in":"656",\n  "timestamp":"2019-05-03T13:11:48-04:00",\n  "method":"PUT",\n  "bytes_out":"10272",\n  "host":"172.128.80.109",\n  "status":"406",\n  "user":"Bins5273",\n  "path":"/mesh"\n}\n')),Object(s.b)("h2",{id:"tutorial"},"Tutorial"),Object(s.b)(o.a,{headingDepth:3,mdxType:"Steps"},Object(s.b)("ol",null,Object(s.b)("li",null,Object(s.b)("h3",{id:"setup-a-basic-pipeline"},"Setup a basic pipeline"),Object(s.b)("p",null,"In the last guide we simply piped stdin to stdout, I'm not trying to diminish\nyour sense of achievement but that was pretty basic."),Object(s.b)("p",null,"This time we're going to build a config we might use in the real world. It's\ngoing to consume logs over TCP with a ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/sources/socket/"}),Object(s.b)("inlineCode",{parentName:"a"},"socket")," source")," and\nwrite them to an ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/sinks/elasticsearch/"}),Object(s.b)("inlineCode",{parentName:"a"},"elasticsearch")," sink"),"."),Object(s.b)(r.a,{type:"info",mdxType:"Alert"},Object(s.b)("p",null,"There's no need to run a local Elasticsearch for this guide as we can write and\neven test our config without connecting to sources or sinks (as you'll see).")),Object(s.b)("p",null,"The basic source to sink version of our pipeline looks like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-toml",metastring:'title="vector.toml"',title:'"vector.toml"'}),'[sources.foo]\n  type = "socket"\n  address = "0.0.0.0:9000"\n  mode = "tcp"\n\n[sinks.bar]\n  inputs = ["foo"]\n  type = "elasticsearch"\n  index = "example-index"\n  host = "http://10.24.32.122:9000"\n')),Object(s.b)("p",null,"If we were to run it then the raw data we consume over TCP would be captured in\nthe field ",Object(s.b)("inlineCode",{parentName:"p"},"message"),", and the object we'd publish to Elasticsearch would look\nlike this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json",metastring:'title="log event"',title:'"log','event"':!0}),'{"message":"172.128.80.109 - Bins5273 656 [2019-05-03T13:11:48-04:00] \\"PUT /mesh\\" 406 10272","host":"foo","timestamp":"2019-05-03T13:11:48-04:00"}\n')),Object(s.b)("p",null,"That's hardly structured at all! Let's remedy that by adding our first transform.")),Object(s.b)("li",null,Object(s.b)("h3",{id:"add-a-parsing-transform"},"Add a parsing transform"),Object(s.b)("p",null,"Nothing in this world is ever good enough for you, why should events be any\ndifferent?"),Object(s.b)("p",null,"Vector makes it easy to mutate events into a more (or less) structured format\nwith ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/transforms/"}),"transforms"),". Let's parse our logs into a structured\nformat by capturing named regular expression groups with a\n",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/transforms/regex_parser/"}),Object(s.b)("inlineCode",{parentName:"a"},"regex_parser")," transform"),"."),Object(s.b)("p",null,"A config can have any number of transforms and it's entirely up to you how they\nare chained together. Similar to sinks, a transform requires you to specify\nwhere its data comes from. When a sink is configured to accept data from a\ntransform the pipeline is complete."),Object(s.b)("p",null,"Let's place our new transform in between our existing source and sink:"),Object(s.b)(i.a,{block:!0,defaultValue:"diff",values:[{label:"Diff",value:"diff"},{label:"Full Config",value:"new_result"}],mdxType:"Tabs"},Object(s.b)(c.a,{value:"diff",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff",metastring:'title="vector.toml"',title:'"vector.toml"'}),' [sources.foo]\n   type = "socket"\n   address = "0.0.0.0:9000"\n   mode = "tcp"\n\n\n+[transforms.apache_parser]\n+  inputs = ["foo"]\n+  type = "regex_parser"\n+  field = "message"\n+  regex = \'^(?P<host>[\\w\\.]+) - (?P<user>[\\w]+) (?P<bytes_in>[\\d]+) \\[(?P<timestamp>.*)\\] "(?P<mathod>[\\w]+) (?P<path>.*)" (?P<status>[\\d]+) (?P<bytes_out>[\\d]+)$\'\n+\n [sinks.bar]\n-  inputs = ["foo"]\n+  inputs = ["apache_parser"]\n   type = "elasticsearch"\n   index = "example-index"\n   host = "http://10.24.32.122:9000"\n'))),Object(s.b)(c.a,{value:"new_result",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-toml",metastring:'title="vector.toml"',title:'"vector.toml"'}),'[sources.foo]\n  type = "socket"\n  address = "0.0.0.0:9000"\n  mode = "tcp"\n\n[transforms.apache_parser]\n  inputs = ["foo"]\n  type = "regex_parser"\n  field = "message"\n  regex = \'^(?P<host>[\\w\\.]+) - (?P<user>[\\w]+) (?P<bytes_in>[\\d]+) \\[(?P<timestamp>.*)\\] "(?P<mathod>[\\w]+) (?P<path>.*)" (?P<status>[\\d]+) (?P<bytes_out>[\\d]+)$\'\n\n[sinks.bar]\n  inputs = ["apache_parser"]\n  type = "elasticsearch"\n  index = "example-index"\n  host = "http://10.24.32.122:9000"\n')))),Object(s.b)("p",null,"This regular expression looks great and it probably works, but it's best to be\nsure, right? Which leads us onto the next step.")),Object(s.b)("li",null,Object(s.b)("h3",{id:"test-it"},"Test it"),Object(s.b)("p",null,"No one is saying that unplanned explosions aren't cool, but you should be doing\nthat in your own time. In order to test our transform we ",Object(s.b)("em",{parentName:"p"},"could")," set up a local\nElasticsearch instance and run the whole pipeline, but that's an awful bother\nand Vector has a much better way."),Object(s.b)("p",null,"Instead, we can write ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/guides/advanced/unit-testing/"}),"unit tests")," as part of our\nconfig just like you would for regular code:"),Object(s.b)(i.a,{block:!0,defaultValue:"diff",values:[{label:"Diff",value:"diff"},{label:"Full Config",value:"new_result"}],mdxType:"Tabs"},Object(s.b)(c.a,{value:"diff",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff",metastring:'title="vector.toml"',title:'"vector.toml"'}),'# Write the data\n[sinks.bar]\n  inputs = ["apache_parser"]\n  type = "elasticsearch"\n  index = "example-index"\n  host = "http://10.24.32.122:9000"\n+\n+[[tests]]\n+  name = "test apache regex"\n+\n+  [[tests.inputs]]\n+    insert_at = "apache_parser"\n+    type = "raw"\n+    value = "172.128.80.109 - Bins5273 656 [2019-05-03T13:11:48-04:00] \\"PUT /mesh\\" 406 10272"\n+\n+  [[tests.outputs]]\n+    extract_from = "apache_parser"\n+    [[tests.outputs.conditions]]\n+      type = "check_fields"\n+      "method.eq" = "PUT"\n+      "host.eq" = "172.128.80.109"\n+      "timestamp.eq" = "2019-05-03T13:11:48-04:00"\n+      "path.eq" = "/mesh"\n+      "status.eq" = "406"\n'))),Object(s.b)(c.a,{value:"new_result",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-toml",metastring:'title="vector.toml"',title:'"vector.toml"'}),'# Consume data\n[sources.foo]\n  type = "socket"\n  address = "0.0.0.0:9000"\n  mode = "tcp"\n\n# Structure the data\n[transforms.apache_parser]\n  inputs = ["foo"]\n  type = "regex_parser"\n  field = "message"\n  regex = \'^(?P<host>[\\w\\.]+) - (?P<user>[\\w]+) (?P<bytes_in>[\\d]+) \\[(?P<timestamp>.*)\\] "(?P<mathod>[\\w]+) (?P<path>.*)" (?P<status>[\\d]+) (?P<bytes_out>[\\d]+)$\'\n\n# Write the data\n[sinks.bar]\n  inputs = ["apache_parser"]\n  type = "elasticsearch"\n  index = "example-index"\n  host = "http://10.24.32.122:9000"\n\n[[tests]]\n  name = "test apache regex"\n\n  [[tests.inputs]]\n    insert_at = "apache_parser"\n    type = "raw"\n    value = "172.128.80.109 - Bins5273 656 [2019-05-03T13:11:48-04:00] \\"PUT /mesh\\" 406 10272"\n\n  [[tests.outputs]]\n    extract_from = "apache_parser"\n    [[tests.outputs.conditions]]\n      type = "check_fields"\n      "method.eq" = "PUT"\n      "host.eq" = "172.128.80.109"\n      "timestamp.eq" = "2019-05-03T13:11:48-04:00"\n      "path.eq" = "/mesh"\n      "status.eq" = "406"\n')))),Object(s.b)("p",null,"This unit test spec has a name, defines an input event to feed into our pipeline\nat a specific transform (in this case our ",Object(s.b)("em",{parentName:"p"},"only")," transform), and defines where\nwe'd like to capture resulting events coming out along with a condition to check\nthe events against."),Object(s.b)("p",null,"When we run:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"vector test ./vector.toml\n")),Object(s.b)("p",null,"It will parse and execute our test:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-text"}),'Running vector.toml tests\ntest vector.toml: test apache regex ... failed\n\nfailures:\n\n--- vector.toml ---\n\ntest \'test apache regex\':\n\ncheck transform \'apache_parser\' failed conditions:\n  condition[0]: predicates failed: [ method.eq: "PUT" ]\npayloads (events encoded as JSON):\n  input: {"timestamp":"2020-02-20T10:19:27.283745Z","message":"172.128.80.109 - Bins5273 656 [2019-05-03T13:11:48-04:00] \\"PUT /mesh\\" 406 10272"}\n  output: {"bytes_in":"656","timestamp":"2019-05-03T13:11:48-04:00","mathod":"PUT","bytes_out":"10272","host":"172.128.80.109","status":"406","user":"Bins5273","path":"/mesh"}\n')),Object(s.b)("p",null,"By Jove! There ",Object(s.b)("em",{parentName:"p"},"was")," a problem with our regular expression! Our test has pointed\nout that the predicate ",Object(s.b)("inlineCode",{parentName:"p"},"method.eq")," failed, and has helpfully printed our input\nand resulting events in JSON format."),Object(s.b)("p",null,"This allows us to inspect exactly what our transform is doing, and it turns out\nthat the method from our Apache log is actually being captured in a field\n",Object(s.b)("inlineCode",{parentName:"p"},"mathod"),"."),Object(s.b)("p",null,"See if you can spot the typo, once it's fixed we can run\n",Object(s.b)("inlineCode",{parentName:"p"},"vector test ./vector.toml")," again and we should get this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-text"}),"Running vector.toml tests\ntest vector.toml: test apache regex ... passed\n")),Object(s.b)("p",null,"Success! Next, try experimenting by adding more ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/transforms/"}),"transforms")," to\nyour pipeline before moving onto the next guide."),Object(s.b)(r.a,{type:"info",mdxType:"Alert"},Object(s.b)("p",null,"While we're at, did you know you can control all of Vector's field names via\nthe ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/global-options/#log_schema"}),"global ",Object(s.b)("inlineCode",{parentName:"a"},"log_schema")," options"),"?\nVector does not lock you into any specific schema."))))),Object(s.b)("h2",{id:"next-steps"},"Next Steps"),Object(s.b)("p",null,"Now that you're a Vector pro you'll have endless ragtag groups of misfits\ntrying to recruit you as their hacker, but it won't mean much if you can't\ndeploy Vector. Onto the next guide!"))}b.isMDXComponent=!0}}]);