(window.webpackJsonp=window.webpackJsonp||[]).push([[951],{1110:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return m})),n.d(t,"metadata",(function(){return d})),n.d(t,"rightToc",(function(){return u})),n.d(t,"default",(function(){return b}));var a=n(1),i=n(9),s=(n(0),n(1139)),r=n(1217),o=n(1176),l=n(1166),c=n.n(l),m={last_modified_on:"2020-04-19",$schema:"/.meta/.schemas/guides.json",title:"Merge multi-line logs with Lua",description:"Combine multi-line CSV rows into single events using Lua transform",author_github:"https://github.com/a-rodin",tags:["type: guide","domain: transforms","transform: lua"]},d={categories:[{name:"advanced",title:"Advanced",description:"Go beyond the basics, become a Vector pro, and extract the full potential of Vector.",permalink:"/guides/advanced"}],coverLabel:"Merge multi-line logs with Lua",description:"Combine multi-line CSV rows into single events using Lua transform",permalink:"/guides/advanced/merge-multiline-logs-with-lua",readingTime:"5 min read",source:"@site/guides/advanced/merge-multiline-logs-with-lua.md",tags:[{label:"type: guide",permalink:"/guides/tags/type-guide"},{label:"domain: transforms",permalink:"/guides/tags/domain-transforms"},{label:"transform: lua",permalink:"/guides/tags/transform-lua"}],title:"Merge multi-line logs with Lua",truncated:!1,prevItem:{title:"Managing Schemas in Vector",permalink:"/guides/advanced/schemas"},nextItem:{title:"Parsing CSV logs with Lua",permalink:"/guides/advanced/parsing-csv-logs-with-lua"}},u=[{value:"A Minimal Example",id:"a-minimal-example",children:[]},{value:"How It Works",id:"how-it-works",children:[]},{value:"Safety Checks",id:"safety-checks",children:[]},{value:"Further Steps",id:"further-steps",children:[]}],g={rightToc:u};function b(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},g,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)(r.a,{name:"guide",mdxType:"Assumptions"},Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"You understand the ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/reference/transforms/lua/"}),"basic Lua concepts"),"."),Object(s.b)("li",{parentName:"ul"},"You understand the ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/about/concepts/"}),"basic Vector concepts")," and understand ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"/guides/getting-started/your-first-pipeline/"}),"how to set up a pipeline"),"."),Object(s.b)("li",{parentName:"ul"},"You know how to ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"/guides/advanced/parsing-csv-logs-with-lua/"}),"parse CSV logs with Lua"),"."))),Object(s.b)("p",null,"The ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/guides/advanced/parsing-csv-logs-with-lua/"}),"guide on parsing CSV logs with Lua")," describes how to parse CSV logs containing\nvalues which do not contain line breaks. However, according to ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://tools.ietf.org/html/rfc4180"}),"RFC 4180"),", CSV values enclosed in double\nquotes can contain line breaks. This means that parsing arbitrary CSV logs requires handling such lines breaks\ncorrectly."),Object(s.b)("p",null,"For general case, this cannot be accomplished using the\n",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/sources/file/#multiline"}),Object(s.b)("inlineCode",{parentName:"a"},"multiline")," option of the ",Object(s.b)("inlineCode",{parentName:"a"},"file")," source")," because it uses regular expressions\nfor delimiting lines, and for the given use case a full-fledged CSV parser is necessary."),Object(s.b)("h2",{id:"a-minimal-example"},"A Minimal Example"),Object(s.b)("p",null,"It is possible to implement merging of CSV log lines using the same ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/geoffleyland/lua-csv"}),Object(s.b)("inlineCode",{parentName:"a"},"lua-csv"))," module as\nin the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/guides/advanced/parsing-csv-logs-with-lua/"}),"guide on parsing CSV logs"),". The underlying algorithm is the following\nfollowing:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"Parse incoming log line as a CSV row."),Object(s.b)("li",{parentName:"ol"},"Check the number of fields in it.",Object(s.b)("ol",{parentName:"li"},Object(s.b)("li",{parentName:"ol"},"If the number of fields matches the expected number of fields,\nthen the log line contains all necessary fields and can be\nprocessed further."),Object(s.b)("li",{parentName:"ol"},"Otherwise, store the log line in the state of the transform and\nthen, when the next event comes, merge the subsequent log line\nwith the previous ones and repeat parsing again.")))),Object(s.b)("p",null,"Such an algorithm can be implemented, for example, with the following transform config:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-toml",metastring:'title="vector.toml"',title:'"vector.toml"'}),'[transforms.lua]\n  inputs = []\n  type = "lua"\n  version = "2"\n  source = """\n    csv = require("csv") -- load the `lua-csv` module\n    expected_columns = 23 -- expected number of columns in incoming CSV lines\n    line_separator = "\\\\r\\\\n" -- note the double escaping required by the TOML format\n  """\n  hooks.process = """\n    function (event, emit)\n      merged_event = merge(event)\n      if merged_event == nil then -- a global variable containing the merged event\n        merged_event = event -- if it is empty, set it to the current event\n      else -- otherwise, concatenate the line in the stored merged event\n           -- with the next line\n        merged_event.log.message = merged_event.log.message ..\n                                  line_separator .. event.log.message\n      end\n\n      fields = csv.openstring(event.log.message):lines()() -- parse CSV\n      if #fields < expected_columns then\n        return -- not all fields are present in the merged event yet\n      end\n\n      -- do something with the array of the parsed fields\n      merged_event.log.csv_fields = fields -- for example, just store them in an\n                                           -- array field\n\n      emit(merged_event) -- emit the resulting event\n      merged_event = nil -- clear the merged event\n    end\n  """\n')),Object(s.b)(o.a,{mdxType:"CodeExplanation"},Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("inlineCode",{parentName:"li"},"source")," option defines code which is executed when the transform is created."),Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("inlineCode",{parentName:"li"},"hooks.process")," option defines a function which is called for each incoming event."))),Object(s.b)("h2",{id:"how-it-works"},"How It Works"),Object(s.b)("p",null,"The merging process can be represented using the following diagram:"),Object(s.b)(c.a,{src:"/img/merge-transform.svg",mdxType:"SVG"}),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"lua")," transform has internal state, which can be accessed and modified from user-defined code\nusing global variables. Initially, the state is empty, which corresponds to ",Object(s.b)("inlineCode",{parentName:"p"},"merged_event")," variable\nbeing set to ",Object(s.b)("inlineCode",{parentName:"p"},"nil"),"."),Object(s.b)("p",null,"As events arrive to the transform, they cause the ",Object(s.b)("inlineCode",{parentName:"p"},"merged_event")," variable to hold an aggregated\nevent, thus making the event non-empty."),Object(s.b)("p",null,"In the end, when the state holds enough data to extract all fields, a merged event is emitted and\nthe state is emptied. Then the process repeats as new events arrive."),Object(s.b)("h2",{id:"safety-checks"},"Safety Checks"),Object(s.b)("p",null,"The merging algorithm used above is simple and would work for data coming from trusted sources. However,\nin general case it might happen that the CSV is malformed, so that some field is not terminated by ",Object(s.b)("inlineCode",{parentName:"p"},'"'),",\nwhich can cause unbounded growth of the ",Object(s.b)("inlineCode",{parentName:"p"},"message")," field. In order to prevent this, it is possible to replace\nthe following lines"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"merged_event.log.message = merged_event.log.message ..\n                           line_separator .. event.log.message\n")),Object(s.b)("p",null,"in the definition of the ",Object(s.b)("inlineCode",{parentName:"p"},"process")," hook by this code:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"merged_event = safe_merge(merged_event, event)\nif not merged_event then\n  return\nend\n")),Object(s.b)("p",null,"and add the following definition of the ",Object(s.b)("inlineCode",{parentName:"p"},"safe_merge")," function to the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/transforms/lua/#source"}),Object(s.b)("inlineCode",{parentName:"a"},"source")),"\nsection of the config:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function safe_merge(merged_event, event)\n  if #merged_event.log.message + #event.log.message > 4096 then\n    return nil\n  else\n    merged_event.log.message = merged_event.log.message ..\n                               line_separator .. event.log.message\n    return merged_event\n  end\nend\n")),Object(s.b)("p",null,"This function checks whether the total length of merged lines not larger than 4096 (the actual value can be made\nlarger if it is necessary by a particular use case) and, if that is the case, performs actual merging."),Object(s.b)("p",null,"In general, it is recommended to always add such safety checks to the code of your custom transforms in order to\nensure that malformed input would not cause memory leaks or other kinds of undesired behavior."),Object(s.b)("h2",{id:"further-steps"},"Further Steps"),Object(s.b)("p",null,"After the problem of merging multi-line logs in custom formats is solved, you might be interested\nin checking out the following guides:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"/guides/advanced/unit-testing/"}),"Unit Testing Your Configs")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"/guides/advanced/custom-aggregations-with-lua/"}),"Custom Aggregations with Lua"))))}b.isMDXComponent=!0},1217:function(e,t,n){"use strict";n(1149);var a=n(0),i=n.n(a),s=n(1183);t.a=function(e){var t=e.children,n=e.name;return i.a.createElement(s.a,{type:"info",fill:!0,icon:!1,rounded:!0,className:"list--icons list--icons--arrow list--tight list--indent margin-bottom--lg"},i.a.createElement("p",{class:"text--lg margin-bottom--sm",style:{marginTop:"-0.25em"}},"Before you begin, this ",n||"page"," assumes the following:"),t)}}}]);